<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>WDD 330 Portfolio - Week 4 Notes</title>
    <link rel="stylesheet" href="/styles.css" />
  </head>
  <body>
     <main>
      <h1>Week 4 Notes</h1>
      <h2>Novice To Ninja : Forms - Lesson 8 Notes</h2>
     
      <p>

        • Forms are made up of a form element that contains form controls such as input fields, select menus and buttons. These input fields can be populated with information that is processed once the form has been submitted.<br>
        • When it comes to forms, there are plenty of usability and accessibility considerations to keep in mind, such as using correct and semantic markup, making forms keyboard accessible and using WAI-AIRA labels. Most of these fall outside the scope of this book, as we'll be keeping the focus on how to use JavaScript to interact with the forms.<br>
        • The legacy DOM had a useful property called document.forms that returns an HTML collection of all the forms in the document in the order they appear in the markup. A form object also has a method called elements that returns an HTML collection of all the elements contained in the form. <br>
        • The form.submit() method will submit the form automatically. Note that submitting a form using this method won’t trigger the form submit event that's covered in the next section. & The form.reset() method will reset all the form controls back to their initial values specified in the HTML.<br>
        • Reset buttons are generally considered poor for usability, as they are too easy to click and then wipe out all the data that’s been entered. So think very carefully before using one in a form.<br>
        • The focus event occurs when an element is focused on. In the case of an input element, this is when the cursor is placed inside the element (either by clicking or tapping on it or navigating to it using the keyboard).<br>
        • Text input element objects have a value property that can be used to retrieve the text inside the field. We can use this to report back what the user has searched for. <br>
        • The input element includes some of the new attributes introduced in HTML5. & The placeholder attribute will insert the value provided in the input field until the user enters some text. This can be useful to place hints about how to fill in the form.<br>
        • Input fields are the most common types of form control, but there are several categories of input field as you’ll soon see: Text,Password,Email,Checkbox,Radio Button,Hidden,File,Other,etc.<br>
        • Form validation is the process of checking whether a user has entered the information into a form correctly. Validation can occur on the client side using JavaScript, and on the server side. It is advisable to use both client-side and server-side validation. JavaScript should not be relied upon to validate any data before it’s saved to a database.<br>
        • It would be better to place any styles in an external CSS file, but for the purposes of this example, it's easier to put it straight into the HTML file.<br>
        • In a real application, you might end up having to validate many different elements according to various different rules. If this is the case, it would make sense to write some more generic addError() and removeError() functions to deal with the different types of validation you might want to apply to the various elements in a form.<br>
        • Another useful technique that can aid usability is to disable the submit button if there are errors on the form. If the submit button is disabled then no action is taken when it’s clicked. Most browsers will also display it in a lighter color to indicate that it cannot be clicked on. This prevents users from submitting a form containing any errors.<br>
        • Be careful referencing elements in this way, however. If the form had the same name as any properties or methods of the document.forms object, such as 'submit', for example, that property or method would be referenced instead of the form element. <br>
        • Select drop-down lists => can be used to select one or more options from a list of values. The 'multiple' attribute is required if more than one option is to be selected. We’ll use one in our example to choose the city where our hero operates.<br>
        • A textarea element is used to enter long pieces of text over multiple lines such as a comment or blog post. They work in much the same way as input fields. We access them using the 'name' attribute, and use the value property to see what text was entered.<br>
        • The HTML5 form validation API can be used to automatically validate a form, but only at a basic level, so a custom validation script may be required.<br>
      </p>
     
     
      <h2>Novice To Ninja : Object-Oriented Programming (OOP) in JS - Lesson 12 Notes</h2>
     
      <p>
        • Object-oriented programming (OOP for short) is a style of programming that involves separating the code into objects that have properties and methods. This approach has the benefit of keeping related pieces of code encapsulated in objects that maintain state throughout the life of the program.<br>
        • Object-oriented programming is often used to model representations of objects in the real world. There are three main concepts in OOP: encapsulation, polymorphism and inheritance.<br>
        • <br>
        • <br>
        • <br>
        • ES6 introduced the new class declaration syntax that does exactly the same thing as a constructor function, but looks much similar to writing a class in a class-based programming language.The ES6 class declarations are preferable to the constructor function syntax because they are more succinct, easier to read and all code in a class definition is implicitly in strict mode, so doesn't need the 'use strict' statement. Using ES6 class declarations also avoids a number of pitfalls associated with constructor functions.<br>
        • The ES6 class declarations are preferable to the constructor function syntax because they are more succinct, easier to read and all code in a class definition is implicitly in strict mode, so doesn't need the 'use strict' statement. Using ES6 class declarations also avoids a number of pitfalls associated with constructor functions.<br>
        • All objects have a constructor property that returns the constructor function that created it & We can use the constructor property to instantiate a copy of an object, without having to reference the actual constructor function or class declaration directly.<br>
        • The static keyword can be used in class declarations to create a static method. These are sometimes called class methods in other programming languages. A static method is called by the class directly rather than by instances of the class.<br>
        • JavaScript uses a prototypal inheritance model. This means that every class has a prototype property that is shared by every instance of the class. So any properties or methods of a class’s prototype can be accessed by every object instantiated by that class.<br>
        • When creating a class, you would normally add any default properties and methods to the class declaration. But what if you want to augment the class with extra methods and properties after it has been created? It turns out that you can still do this using the prototype property of the class.<br>
        • The prototype object is live, so if a new property or method is added to the prototype, any instances of its class will inherit the new properties and methods automatically, even if that instance has already been created.<br>
        • It is not possible to overwrite the prototype by assigning it to a new object literal if class declarations are used. An object instance can overwrite any properties or methods inherited from its prototype by simply assigning a new value to them. <br>
        • The prototype can be used to add any new properties and methods after the class has been declared. It should be used to define any properties that will remain the same for every instance of the class. <br>
        • Be careful when using the prototype to set default values. They are shallow, (There’s more about shallow and deep copies later in the chapter.) so any changes to an array or object made by an instance will be reflected in the prototype, and therefore shared between all instances.<br>
        • A golden rule to remember is: Never use arrays or objects as a default value in prototype.<br>
        • Enumerable Properties => Properties of objects in JavaScript are said to be enumerable or non-enumerable. If they aren't enumerable, this means they will not show up when a for-in loop is used to loop through an object’s properties and methods.<br>
        • The concept of polymorphism means that different objects can have the same method, but implement it in different ways. The Object.prototype object has a toString() method that is shared by all objects. This means every object created in JavaScript will have a toString() method. <br>
        • Polymorphism means that objects are able to override this method with a more specific implementation. So although every object has a toString() method, the way it’s implemented can vary between different objects.<br>
        • The number, string, and boolean primitive types that we met way back in Chapter 2 have their own corresponding constructor functions: Number, String, and Boolean respectively.<br>
        • Primitives are actually without their own methods. The primitive wrapper objects Number, String, and Boolean are used in the background to provide primitive values with methods. When a method is called on a primitive value, JavaScript creates a wrapper object for the primitive, which converts it into an object and then calls the method on the object. <br>
        • It is possible to add more methods to the prototype of JavaScript’s built-in objects — such as Number, String, and Array — to add more functionality. This practice is known as monkey-patching, but it’s mostly frowned upon in the JavaScript community, despite it being an incredibly powerful technique (The Ruby programming community, on the other hand, generally embrace monkey-patching, so it is quite common in Ruby code examples.) .<br>
        • While monkey-patching built-in objects can seem a good way to add extra or missing functionality, it can also add unexpected behavior. The current consensus in the JS community is that this shouldn't be done, so you should avoid monkey-patching any of the built-in object constructor prototypes, unless you have a very good reason. Further problems could occur if the method you’ve added is then implemented natively in the language.<br>
        • We’ve already seen that all objects are collections of key-value paired properties. It turns out that each property has a number of attributes that provide information about the property. These attributes are stored in a property descriptor, which is an object that contains values of each attribute.<br>
        • The Object() constructor function has a number of methods for getting and defining property descriptors. We can see these values using the Object.getOwnPropertyDescriptor() method<br>
        • An object property descriptor can have get() and set() methods instead of a value attribute. All objects must have one or the other, they can't have both. The get() and set() methods can be used to control how a property is set using assignment and the value that is returned when a property is queried.<br>
        • The Object() constructor function has a method called create that can be used to create a new object that is an exact copy of the object that is provided as an argument. The object that is provided as the argument acts as the prototype for the new object.<br>
        • Every time a new object is created using the Object.create() method, the new object inherits all the properties and methods from the parent object, which becomes the new object’s prototype. <br>
        • The Human object will be the prototype for any objects created using it as an argument and remember that prototypes are live. This means that any changes made to the Human object will be reflected in all the objects created this way.<br>
        • A mixin is a way of adding properties and methods of some objects to another object without using inheritance. It allows more complex objects to be created by ‘mixing’ basic objects together.<br>
        • When objects are copied by assignment, they are only copied by reference. This means that another object is not actually created in memory; the new reference will just point to the old object. Any changes that are made to either objects will affect both of them. Arrays and functions are objects, so whenever they’re copied by assignment they will just point to the same object. And when one changes, they all change. This is known as making a shallow copy of an object.<br>
        • Inheritance allows us to add functionality to objects by inheriting properties and methods from other objects. While this is useful, it can be undesirable to create a chain of inheritance ― sometimes we just want to add properties and methods without linking the two objects together. <br>
        • Borrowing Methods from Prototypes => It’s possible to borrow methods from objects without having to inherit all their properties and methods. This is done by making a reference to the function that you want to borrow (that is, without parentheses so that it isn’t invoked).<br>
        <button onclick="location.href ='../test4_0.html'">Click Here To Go Test for OOPS.</button>

      </p>
     
     
      <h2>Novice To Ninja : Modern JS Development - Lesson 15 Notes</h2>
      
      <p>
        • A JavaScript library is a piece of code that provides several methods that make it easier to achieve common tasks. JavaScript is an extremely flexible language that can accomplish most programming tasks – but not all undertakings are as easy to do as they should be. <br>
        • A library will abstract functionality into easier-to-use functions and methods. These can then be used to complete common tasks without having to use lots of repetitive code.<br>
        • A good example of how libraries can help save time is in DOM manipulation. The DOM API provides all the tools required to manipulate the DOM, but some can be verbose and take several lines of code to attain even the most basic of tasks.<br>
        • jQuery is the most popular of all the JavaScript libraries used today, as seen in these statistics on W3Techs and Built With.. It is used in a huge number of commercial websites and has a plugin system that makes it easy to extend and use to build common web page elements, such as a lightbox or carousel widget.<br>
        • Underscore and Lodash are very similar libraries of functions that provide additional functionality to the language. They both provide a large number of utility functions under the namespace _ (this is where they get their name from as the _ character is often referred to as an 'underscore' or a 'lodash'). <br>
        • The jQuery library uses the $ symbol as a convenient alias for the the global jQuery object that contains all of jQuery's methods. This prevents the global scope from being polluted with any of jQuery’s methods. The $ symbol has become synonymous with jQuery, and you can confidently expect that any mention of it implies that jQuery is being used.<br>
        • Libraries are often the pragmatic choice to complete a project in a realistic time frame, especially when working in a large team. They can also be useful in supporting older browsers and ironing out any browser-specific bugs or quirks, or if performance isn’t the most important factor (when prototyping sites, for example).<br>
        • When to Use a Library? =>An example of this is jQuery. While it contains a large number of useful methods, it also provides many features that are often unnecessary. jQuery's modular structure means that you can include only the parts you need on a module-by-module basis. <br>
        • Be careful not to rely on a library and find that you’re learning how to use the library's methods, rather than the language itself. A library should not be used because of a lack of understanding of JavaScript. Instead, it should be used to speed up JavaScript development by making it easier to complete common tasks.<br>
        • A module is a self-contained piece of code that provides functions and methods that can then be used in other files and by other modules. This helps to keep code organized in separate, reusable files, which improves code maintainability.<br>
        • At the time of writing, most major browsers are on the cusp of supporting ES6 modules, so you should be able to run these examples straight in your browser. If they don't work, however, you can use a build process that packages all the modules together into one file. We explain how to do this later in this chapter.<br>
        • Having more than one default export will result in a syntax error.<br>
        • The alias that is assigned to the imported module does not have to match its name in the actual module. <br>
        • ode.js had already implemented modules before they were introduced in ES6, and used a slightly different notation called Common JS modules. At the time of writing it is proving difficult to merge the two notations in an elegant way, although it is expected that Node.js will support ES6 modules in some way in the future.<br>
        • Model-View-Controller (MVC) is a design pattern that’s been used for a long time in server-side languages. It’s a common way of designing software, and used by server-side frameworks such as Ruby On Rails and Django. In recent years it has been used in JavaScript code to make it easier to organize large-scale web applications.<br>
        • An MVC architecture can take a lot of code to implement, and many frameworks have emerged that take care of much of the setup code for you. One of the main features of MVC frameworks is data binding, which is the process of linking the model and view together.<br>
        • Minification is the process of removing any redundant characters from the code in order to reduce its file size.
        • Files can be compressed on the server using the gzip compression tool.
        • Webpack can be used to bundle multiple files into a single bundle, and automate common tasks such as transpiling, minifying code and running tests.
        • Before code is deployed, it should be concatenated into a single file, minified and compressed. The script tag should be placed just before the closing </body> tag to ensure that all elements on the page have loaded before the script runs.<br>
        
    </p>


     
      <button onclick="location.href ='../'">Click Here To Go Back To Portfolio </button>
      <button onclick="location.href ='../test4.html'">Click Here To Go To Example Code which is tested.</button>
      <button onclick="location.href ='../hero.html'">Click Here To Go To Example Code for Forms which is tested. </button>
      <button onclick="location.href ='https://codepen.io/daz4126/pen/ZyoyOz'">Click Here To Go CodePen for Forms.</button>

    <footer>Portfolio WDD 330 | Week 4</footer>
  </body>
</html>
