<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" >
    <meta name="viewport" content="width=device-width, initial-scale=1.0" >
    <title>WDD 330 Portfolio - Week 10 Notes</title>
    <link rel="stylesheet" href="../css/style.css" >
  </head>
  <body>
    <main>
      <h1>Week 10 Notes</h1>
      <h2>MDN: Using Fetch</h2>

      <p>
      • ➡️ The Fetch API provides a JavaScript interface for accessing and manipulating parts of the protocol, such as requests and responses. It also provides a global fetch(). <br>
      • This kind of functionality was previously achieved using XMLHttpRequest. Fetch provides a better alternative that can be easily used by other technologies such as Service Workers. <br>
      • Fetch also provides a single logical place to define other HTTP-related concepts such as CORS and extensions to HTTP. <br>
      • The Response object, in turn, does not directly contain the actual JSON response body but is instead a representation of the entire HTTP response.  <br>
      • The Promise returned from fetch() won't reject on HTTP error status even if the response is an HTTP 404 or 500.  <br>
      • Unless fetch() is called with the credentials option set to include, fetch(): won't send cookies in cross-origin requests won't set any cookies sent back in cross-origin responses As of August 2018, the default credentials policy changed to same-origin. Firefox was also modified in version 61.0b13). <br>
      • Fetch requests are controlled by the connect-src directive of Content Security Policy rather than the directive of the resources it's retrieving.<br>
      • The fetch() method can optionally accept a second parameter, an init object that allows you to control a number of different settings.<br>
      • To cause browsers to send a request with credentials included on both same-origin and cross-origin calls, add credentials: 'include' to the init object you pass to the fetch() method.<br>
      • Use fetch() to POST JSON-encoded data. & Files can be uploaded using an HTML input type="file"  input element, FormData() and fetch().<br>
      • The chunks that are read from a response are not broken neatly at line boundaries and are Uint8Arrays, not strings. If you want to fetch a text file and process it line by line, it is up to you to handle these complications. <br>
      • A fetch() promise will reject with a TypeError when a network error is encountered or CORS is misconfigured on the server-side, although this usually means permission issues or similar — a 404 does not constitute a network error, for example.<br>
      • An accurate check for a successful fetch() would include checking that the promise resolved, then checking that the Response.ok property has a value of true.<br>
      • ➡️ Request() accepts exactly the same parameters as the fetch() method. You can even pass in an existing request object to create a copy of it.<br>
      • The Headers interface allows you to create your own headers object via the Headers() constructor.<br>
      • All of the Headers methods throw a TypeError if a header name is used that is not a valid HTTP Header name. The mutation operations will throw a TypeError if there is an immutable guard.<br>
      • Since headers can be sent in requests and received in responses, and have various limitations about what information can and should be mutable, headers' objects have a guard property. <br>
      • ➡️ They can also be created programmatically via JavaScript, but this is only really useful in ServiceWorkers, when you are providing a custom response to a received request using a respondWith().<br>
      • The Response() constructor takes two optional arguments — a body for the response, and an init object (similar to the one that Request() accepts.<br>
      • The Request and Response interfaces share the following methods to extract a body. These all return a promise that is eventually resolved with the actual content.<br>
      • Fetch API support can be detected by checking for the existence of Headers, Request, Response or fetch() on the Window or Worker scope.<br>
      </p>

      <h2>MDN : Validating Forms</h2>
      
      <p>
      • ➡️ Before submitting data to the server, it is important to ensure all required form controls are filled out, in the correct format.
      <br> This is called client-side form validation, and helps ensure data submitted matches the requirements set forth in the various form controls. <br>   
      • Client-side validation is an initial check and an important feature of good user experience; by catching invalid data on the client-side, the user can fix it straight away.
      <br> If it gets to the server and is then rejected, a noticeable delay is caused by a round trip to the server and then back to the client-side to tell the user to fix their data.<br>   
      • This is called form validation. When you enter data, the browser and/or the web server will check to see that the data is in the correct format and within the constraints set by the application.<br>   
      • Validation done in the browser is called client-side validation, while validation done on the server is called server-side validation. In this chapter we are focusing on client-side validation.<br>   
      • Built-in form validation uses HTML form validation features, which we've discussed in many places throughout this module. This validation generally doesn't require much JavaScript.<br>   
      • JavaScript validation is coded using JavaScript. This validation is completely customizable, but you need to create it all (or use a library).<br>   
      • One of the most significant features of modern form controls is the ability to validate most user data without relying on JavaScript. This is done by using validation attributes on form elements. <br>   
      • required: Specifies whether a form field needs to be filled in before the form can be submitted.<br> 
      • minlength and maxlength: Specifies the minimum and maximum length of textual data (strings).<br> 
      • min and max: Specifies the minimum and maximum values of numerical input types.<br> 
      • type: Specifies whether the data needs to be a number, an email address, or some other specific preset type.<br> 
      • pattern: Specifies a regular expression that defines a pattern the entered data needs to follow.<br>   
      • The simplest HTML validation feature is the required attribute. To make an input mandatory, add this attribute to the element.<br>   
      • Another useful validation feature is the pattern attribute, which expects a Regular Expression as its value. <br>
      • A regular expression (regex) is a pattern that can be used to match character combinations in text strings, so regexps are ideal for form validation and serve a variety of other uses in JavaScript.<br>   
      • ➡️ In some cases, such as custom controls, you won't be able to or won't want to use the Constraint Validation API.<br>   
      • You're still able to use JavaScript to validate your form, but you'll just have to write your own.<br>   
 
      
      </p>
<div style="display: inline-flex;">
    <ul style="display:flex; flex-wrap:wrap;">
      <li><button onclick="location.href ='../'">Click Here To Go Back To Portfolio </button></li>
      <li><button onclick="location.href ='https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch'">Click Here To Go To MDN: Using Fetch.</button></li> 
      <li><button onclick="location.href ='https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation'">Click Here To Go To MDN: Form Validation.</button></li>
    </ul>

</div>

</main>
      <footer>Portfolio WDD 330 | Week 9</footer>
  </body>
</html>